#!/usr/bin/env wish

wm title . "GAMESMAN"
set maxsize [wm maxsize .]
set maxheight [expr int([expr 0.85 * [lindex $maxsize 1]])]
wm geometry . =800x$maxheight
update

global calBlue calYellow
global textGameColor listFont
set calBlue #006
set calYellow #FFCC33
set textGameColor black
set listFont "Helvetica 10"

bind . <Key> {
	global currentId theNumberOfPrograms thePrograms
	#puts "Pressed %K"
	set list .leftSide.list
	set home .rightSide.home

	switch %K {
	Left -
	Up {
		if {$currentId == -1} {
		selectGame 0
		} elseif {$currentId > 0} {
		selectGame [expr $currentId - 1]
		}
	}
	Right -
	Down {
		if {$currentId == -1} {
		selectGame 0
		} elseif {$currentId < [expr $theNumberOfPrograms-1]} {
		selectGame [expr $currentId + 1]
		}
	}
	Return -
	KP_Enter {
		if {[guiExists $currentId]} {
		runGui $currentId
		} elseif {[isGame $currentId]} {
		runText $currentId
		}
	}
	Prior {$list [axisView] scroll -1 pages}
	Next {$list [axisView] scroll 1 pages}
	Home {selectGame 0}
	End {selectGame [expr $theNumberOfPrograms -1]}
	}
}

bind . <Control-Key> {
	global currentId theNumberOfPrograms thePrograms
	set list .leftSide.list
	set home .rightSide.home

	if {[string compare %K "h"] == 0 || [string compare %K "H"] == 0} {
	selectGame -1
	} elseif {[string compare %K "q"] == 0 || [string compare %K "Q"] == 0} {
	exit
	}
}

bind . <Configure> "Resize"

###HELPER FUNCTIONS###
proc max {x y} {
	if {$x > $y} {
	return $x
	} else {
	return $y
	}
}
proc getIdUnderMouse {canvas} {
	set tags [$canvas gettags [$canvas find withtag current]]
	set i [string replace [lindex $tags [lsearch $tags list*]] 0 3]
	return $i
}
proc listItemWidth {} {
	global scrollDirection listFont
	if {$scrollDirection == "vertical"} {
	return 160
	}
	return [expr [maxGameStringWidth $listFont] + 10]
}
proc listItemHeight {} {
	global scrollDirection
	if {$scrollDirection == "vertical"} {
	return 60
	}
	return 80
}
proc maxGameStringWidth {font} {
	global maxGameString theNumberOfPrograms
	if {$maxGameString > 0} {
	return $maxGameString
	}
	for { set i 0 } { $i < $theNumberOfPrograms } { incr i } {
	if {[font measure $font [gameString $i]] > $maxGameString} {
		set maxGameString [font measure $font [gameString $i]]
	}
	}
}
proc axisView {} {
	global scrollDirection
	if {$scrollDirection == "vertical"} {
	return "yview"
	}
	return "xview"
}
proc setListLocation location {
	global listLocation
	set listLocation $location
	if {$listLocation == "top" || $listLocation == "bottom"} {
	horizontalScroll $listLocation
	} else {
	verticalScroll $listLocation
	}
}
proc verticalScroll location {
	global scrollDirection theNumberOfPrograms currentId
	set scrollDirection vertical
	set list .leftSide.list
	set leftScroll .leftSide.leftScroll
	pack forget .leftSide .rightSide $list $leftScroll

	CreateListButtons $list
	$leftScroll configure -orient $scrollDirection \
	-command "$list yview"
	$list configure -width [listItemWidth] \
	-scrollregion [list 0 1 [listItemWidth] [expr 1+$theNumberOfPrograms*[listItemHeight]]] \
	-yscrollcommand "$leftScroll set" \
	-xscrollcommand ""

	pack .leftSide -fill y -side $location
	pack .rightSide -fill both -side $location -expand 1
	
	pack $leftScroll -fill y -side $location
	pack $list -fill y -side $location

	Resize
	$list [axisView] moveto [max 0 [expr ($currentId-1.0)/$theNumberOfPrograms]]
	update

	#save preference to file
	set fileptr [open listLocation.txt w+]
	puts $fileptr $location
	close $fileptr
}
proc horizontalScroll location {
	global scrollDirection theNumberOfPrograms currentId
	set scrollDirection horizontal
	set list .leftSide.list
	set leftScroll .leftSide.leftScroll
	pack forget .leftSide .rightSide $list $leftScroll

	CreateListButtons $list
	$leftScroll configure -orient $scrollDirection \
	-command "$list xview"
	$list configure -height [listItemHeight] \
	-scrollregion [list 0 0 [expr 1+$theNumberOfPrograms*[listItemWidth]] [listItemHeight]] \
	-yscrollcommand "" \
	-xscrollcommand "$leftScroll set"

	pack $leftScroll -fill x -side $location
	pack $list -fill x -side $location

	pack .leftSide -fill x -side $location
	pack .rightSide -fill both -expand 1 -side $location

	Resize
	$list [axisView] moveto [max 0 [expr ($currentId-1.0)/$theNumberOfPrograms]]
	update

	#save preference to file
	set fileptr [open listLocation.txt w+]
	puts $fileptr $location
	close $fileptr
}
proc pageWidth {} {
	global scrollDirection
	if {$scrollDirection == "vertical"} {
	return [expr [winfo width .] - [listWidth]]
	}
	return [winfo width .]
}
proc listWidth {} {
	return 173
}
proc isGame {id} {
	global theNumberOfPrograms
	if {$id < 0 || $id >= $theNumberOfPrograms} {
	return false
	}
	return true
}
proc gameName {id} {
	global thePrograms
	return [lindex $thePrograms $id]
}
proc pageName {id} {
	if {$id == -1} {
	return main
	}
	return [gameName $id]
}
proc gameColor {id} {
	global theGuiTypes
	return [lindex $theGuiTypes $id]
}
proc textColor {id} {
	if {[guiExists $id]} {
	return "black"
	}
	return "white"
}
proc gameString {id} {
	global theStrings
	return [lindex $theStrings $id]
}
proc guiExists {id} {
	global textGameColor
	if {[isGame $id] == false || [gameColor $id] == $textGameColor} {
	return false
	}
	return true
}
proc runGui {id} {
	global thePrograms
	set theGuiProgram "./Xm[lindex $thePrograms $id]"
	exec /usr/bin/env wish -f $theGuiProgram &
}
proc runText {id} {
	global thePrograms
	set theTextProgram "./m[lindex $thePrograms $id]"
	exec /usr/bin/env xterm -n [gameString $id] -e $theTextProgram &
}
proc guiImage { id scale } {
	global theBitmapDir thePrograms
	set theGif "$theBitmapDir/[lindex $thePrograms $id]100.gif"
	catch { image delete guiImage$id }
	image create photo guiImage$id -file $theGif
	set imageName guiImage$id
	if {$scale > 1} {
	set scale [expr int($scale)]
	set imageName [format guiImage%sZoom%s $id $scale]
	catch { image delete $imageName }
	image create photo $imageName
	$imageName copy guiImage$id -zoom $scale
	} elseif {$scale < 1} {
	set scale [expr int(1/$scale)]
	set imageName [format guiImage%sSubsample%s $id $scale]
	catch { image delete $imageName }
	image create photo $imageName
	$imageName copy guiImage$id -subsample $scale
	}

	return $imageName
}
proc textImage {id scale} {
	global theBitmapDir thePrograms
	set theGif "$theBitmapDir/[lindex $thePrograms $id]100text.gif"
	catch { image delete textImage$id }
	image create photo textImage$id -file $theGif
	set imageName textImage$id
	if {$scale > 1} {
	set scale [expr int($scale)]
	set imageName [format textImage%sZoom%s $id $scale]
	catch { image delete $imageName }
	image create photo $imageName
	$imageName copy textImage$id -zoom $scale
	} elseif {$scale < 1} {
	set scale [expr int(1/$scale)]
	set imageName [format textImage%sSubsample%s $id $scale]
	catch { image delete $imageName }
	image create photo $imageName
	$imageName copy textImage$id -subsample $scale
	}

	return $imageName
}
#pos can be "top","middle", or "bottom"
proc selectGame {id args} {
	global currentGame currentId calBlue theNumberOfPrograms
	set list .leftSide.list
	set home .rightSide.home
	set leftScroll .leftSide.leftScroll

	set pos ""
	if {[llength $args] > 0} {
	set pos [lindex $args 0]
	}

	pack forget $home.$currentGame
	if {[isGame $currentId]} {
	$list itemconfigure rect$currentId -fill [gameColor $currentId] \
		-outline RoyalBlue
	$list itemconfigure text$currentId -fill [textColor $currentId]
	}

	set currentId $id
	set currentGame [pageName $id]
	set width [pageWidth]
	$home.$currentGame.title configure -width [expr $width - 20]
	if { [isGame $currentId] == false } {
	$home.$currentGame.desc configure -width [expr $width - 20]
	}
	if { [info exists Desc($currentGame)] } {
	$home.$currentGame.desc configure -width [expr $width - 20]
	}
	if { [info exists Rules($currentGame)] } {
	$home.$currentGame.rules configure -width [expr $width - 20]
	}
	pack $home.$currentGame -fill both -expand 1 -anchor nw
	if {[isGame $currentId]} {
	$list itemconfigure rect$currentId -fill $calBlue -outline $calBlue
	$list itemconfigure text$currentId -fill white

	set top [expr ($currentId+0.0) / $theNumberOfPrograms]
	set bottom [expr ($currentId+1.0) / $theNumberOfPrograms]
	set first [lindex [$leftScroll get] 0]
	set last [lindex [$leftScroll get] 1]
	set diff [expr $last - $first]

	if {$top < $first} {
		if {$pos == "middle"} {
		$list [axisView] moveto [max 0 [expr $bottom - $diff/2]]
		} else {
		$list [axisView] moveto $top
		}
	}
	if {$bottom > $last } {
		if {$pos == "middle"} {
		$list [axisView] moveto [max 0 [expr $bottom - $diff/2]]
		} else {
		$list [axisView] moveto [max 0 [expr $bottom - $diff]]
		}
	}
	}
}

proc parseCfg { in } {
	set fieldDelim {=}
	global thePrograms theStrings theGuiTypes secDelim colors invColors
	
	if [catch {open "$in" {RDONLY}} fin] {
		return
	}

	set cfgName "Config"
	set colorsName "Colors"
	set gameName "game"
	set colorField "color"
	set nameField "basename"
	set cfgType 0
	
	while {![eof $fin]} {
		gets $fin line		
		
		if {[regexp $secDelim $line -> title] > 0} {
			if {$title == $cfgName} {
				set cfgType $cfgName
			} elseif {$title == $colorsName} {
				set cfgType $colorsName
			} else {
				set cfgType $gameName
				lappend theStrings $title
			}
		} elseif {$cfgType == $cfgName} {
			
		} elseif {$cfgType == $colorsName} {
			set parts [split $line $fieldDelim]

			if {[llength $parts] > 0} {
				set field [lindex $parts 0]
				set val [lindex $parts 1]
				set colors($val) $field
				set invColors($field) $val
			}
		} elseif {$cfgType == $gameName} {
			set parts [split $line $fieldDelim]
			
			if {[llength $parts] > 0} {
				set field [lindex $parts 0]
				set val [lindex $parts 1]
				
				if {$field == $colorField} {
					lappend theGuiTypes $colors($val)
				} elseif {$field == $nameField} {
					lappend thePrograms $val
				}
			}
		}	
	}
	
	bSort
	close $fin
}

proc parseInfo { in } {
	global Desc Rules secDelim
	
	if [catch {open "$in" {RDONLY}} fin] {
		return
	}

	set file [file tail $in]
	set file [file rootname $file]
	set file [string range $file 1 [expr [string length $file] - 1]]
	#puts $file
	set rulesName "Rules"
	set descName "Description"
	set cfgType 0
	set buffer ""
	while {![eof $fin]} {
		gets $fin line
				
		if {[regexp $secDelim $line -> title] > 0} {
			if {$cfgType == $rulesName} {
				set Rules($file) $buffer
			} elseif {$cfgType == $descName} {
				set Desc($file) $buffer
			}
			
			set buffer ""
			if {$title == $rulesName} {
				set cfgType $rulesName
			} elseif {$title == $descName} {
				set cfgType $descName
			}
		} else {
			set buffer $buffer$line\n
		}
	}
	
	if {$cfgType == $rulesName} {
		set Rules($file) $buffer
	} elseif {$cfgType == $descName} {
		set Desc($file) $buffer
	}
	
	close $fin
}

proc bSort { } {
	global theStrings theGuiTypes invColors
	set maxLen [llength $theStrings]
	
	for { set i 0 } { $i < $maxLen } { incr i } {
		
		for { set j [expr $i + 1] } { $j < $maxLen } { incr j } {
			set jColor $invColors([lindex $theGuiTypes $j])
			set iColor $invColors([lindex $theGuiTypes $i])
			if {$jColor < $iColor} {
				swap $i $j
			} elseif {$jColor == $iColor && [lindex $theStrings $j] < [lindex $theStrings $i]} {
				swap $i $j
			}
		}
	}
}

proc swap { i j } {
	global thePrograms theStrings theGuiTypes
	set t1 [lindex $thePrograms $i]
	set t2 [lindex $theStrings $i]
	set t3 [lindex $theGuiTypes $i]
	
	set thePrograms [lreplace $thePrograms $i $i [lindex $thePrograms $j]]
	set theStrings [lreplace $theStrings $i $i [lindex $theStrings $j]]
	set theGuiTypes [lreplace $theGuiTypes $i $i [lindex $theGuiTypes $j]]
	
	set thePrograms [lreplace $thePrograms $j $j $t1]
	set theStrings [lreplace $theStrings $j $j $t2]
	set theGuiTypes [lreplace $theGuiTypes $j $j $t3]
}

proc addGame { } {

}

proc createGameList { } {
	global thePrograms theStrings theGuiTypes
}

proc changeGameColor { color } {
	global gamesFile secDelim invColors currentId
	if {![isGame $currentId] || [catch {open "$gamesFile" {RDWR}} fin]} {
		return
	}
	
	set game [gameString $currentId]
	set colorField "color"
	set found 0
	while {![eof $fin]} {
		set offset [tell $fin]
		gets $fin line
		
		if {$found == 1} {
			set parts [split $line =]
			
			if {[llength $parts] > 0} {
				if {[lindex $parts 0] == $colorField} {
					seek $fin [expr $offset + 1 + [string length $colorField]]
					puts $fin $invColors($color)
					break
				}
			}	
		} elseif {$found == 0 && [regexp $secDelim $line -> title] > 0} {
			if {$title == $game} {
				set found 1
			}
		}
	}
	
	close $fin
}

proc refreshGameList { } {

}

proc addToGameList { value } {
	global gamesFile
	if [catch {open "$gamesFile" {RDONLY}} fin] {
		return
	}
	
	puts $fin $value
	close $fin
}

###END HELPER FUNCTIONS###
proc main {} {
	global theBitmapDir thePrograms theStrings theGuiTypes \
	theNumberOfPrograms currentGame currentId \
	calBlue calYellow scrollDirection listLocation maxGameString \
	gamesFile secDelim colors invColors

	set secDelim {\[(.+?)]}
	set theBitmapDir "../bitmaps"
	set gamesFile "./games.txt"
	set thePrograms {}
	set theStrings {}
	set theGuiTypes {}
	parseCfg $gamesFile
	
	set theNumberOfPrograms [llength $thePrograms]
	set currentGame main
	set currentId -1
	set maxGameString 0
	
	menu .menu -tearoff 0 -borderwidth 0 -activeborderwidth 1
	
	canvas .leftSide -highlightthickness 0
	canvas .rightSide -highlightthickness 0

	set list .leftSide.list
	set leftScroll .leftSide.leftScroll

	set home .rightSide.home

	scrollbar $leftScroll \
	-troughcolor $calBlue \
	-background gold \
	-borderwidth 0 \
	-elementborderwidth 1 \
	-highlightthickness 1 \
	-highlightbackground RoyalBlue \
	-width 13
	canvas $list -background $calBlue -highlightthickness 0

	canvas $home -background $calBlue -highlightthickness 0

	pack .leftSide -fill y -side left
	grid rowconfig    .leftSide 0 -weight 1 -minsize 0
	grid columnconfig .leftSide 0 -weight 1 -minsize 0
	pack .rightSide -fill both -side left -expand 1
	
	pack $home -fill both -side right -expand 1 -padx 0 -pady 0

	set scrollDirection vertical
	if {[catch {set fileptr [open listLocation.txt r]}]} {
	set listLocation left
	} else {
	gets $fileptr listLocation
	close $fileptr
	}

	CreateGamePages $home
	CreateMenuItems .menu
	CreateListButtons $list

	setListLocation $listLocation

	$list bind all <Any-Enter> "scrollEnter $list"
	$list bind all <Any-Leave> "scrollLeave $list"
	$list bind all <1> "scrollButton $list"
	$list bind all <Double-1> "scrollDoubleClick $list"

	bind $list <ButtonPress-4> "mouseWheelUp"
	bind $list <ButtonPress-5> "mouseWheelDown"

	bind $leftScroll <ButtonPress-4> "mouseWheelUp"
	bind $leftScroll <ButtonPress-5> "mouseWheelDown"

	. configure -menu .menu
	
}

proc CreateMenuItems menu {
	global listLocation currentId currentGame colors

	set m $menu.file
	menu $m -tearoff 0 -borderwidth 0 -activeborderwidth 1
	$menu add cascade -label "File" -menu $m -underline 0
	$m add command -label "Home" \
	-underline 0 \
	-command "selectGame -1" \
	-accelerator <ctrl-h>
	$m add command -label "Quit" \
	-underline 0 \
	-command exit \
	-accelerator <ctrl-q>

	set m $menu.games
	menu $m -tearoff 1 -borderwidth 0 -activeborderwidth 1
	$menu add cascade -label "Games" -menu $m -underline 0
	global theNumberOfPrograms
	set height [winfo height .]
	
	for { set i 0 } { $i < $theNumberOfPrograms } { incr i } {
		set cBreak 0
		if {[$m yposition $i] > [expr $height-40]} {
			set cBreak 1
		}
		
		$m add command -label [gameString $i] -underline 0 \
		-command "selectGame $i middle" -columnbreak $cBreak
	}
	
	set m $menu.view
	menu $m -tearoff 0 -borderwidth 0  -activeborderwidth 1
	$menu add cascade -label "View" -menu $m -underline 0

	set mList $menu.view.listPos
	menu $mList -tearoff 0 -borderwidth 0  -activeborderwidth 1
	$m add cascade -label "List Position" -menu $mList -underline 0

	$mList add radio -label "Left" \
	-variable listLocation \
	-value "left" \
	-command "setListLocation left"
	$mList add radio -label "Right" \
	-variable listLocation \
	-value "right" \
	-command "setListLocation right"
	$mList add radio -label "Top" \
	-variable listLocation \
	-value  "top" \
	-command "setListLocation top"
	$mList add radio -label "Bottom" \
	-variable listLocation \
	-value  "bottom" \
	-command "setListLocation bottom"
	
	
	set m $menu.cfg
	menu $m -tearoff 0 -borderwidth 0  -activeborderwidth 1
	$menu add cascade -label "Set game color" -menu $m -underline 0

	foreach idx [array names colors] {
		$m add command -label $colors($idx) -underline 0 \
		-command "changeGameColor $colors($idx)"
	}
	

}

proc CreateListButtons list {
	global theNumberOfPrograms scrollDirection currentId listFont
	set imageScale 0.5
	set imageSize [expr 100 * $imageScale]
	set textAnchor "e"
	set imageAnchor "w"
	set textWidth [expr [listItemWidth] - $imageSize - 10]
	if {$scrollDirection == "horizontal"} {
	set textAnchor "n"
	set imageAnchor "n"
	set textWidth [expr [listItemWidth] - 10]
	}
	for { set i 0 } { $i < $theNumberOfPrograms } { incr i } {
	if {[guiExists $i]} {
		set imageFn "guiImage"
	} else {
		set imageFn "textImage"
	}
	set rectCoords [list -1 [expr 1+$i*[listItemHeight]] \
				[expr [listItemWidth] - 1] \
				[expr ($i+1)*[listItemHeight]]]
	set textCoords [list [expr [listItemWidth]-5] \
				[expr 1+[listItemHeight]/2+$i*[listItemHeight]]]
	set imageCoords [list 5 [expr 1+[listItemHeight]/2+$i*[listItemHeight]]]
	if {$scrollDirection == "horizontal"} {
		set rectCoords [list [expr [listItemWidth]*$i] 0 \
				[expr ($i+1)*[listItemWidth]-1] \
				[expr [listItemHeight]-0]]
		set textCoords [list [expr [listItemWidth]*($i+1)-[listItemWidth]/2] \
				[expr $imageSize+10]]
		set imageCoords [list [expr [listItemWidth]*$i+[listItemWidth]/2] 5]
	}
	$list create rect $rectCoords \
		-outline RoyalBlue \
		-fill [gameColor $i] \
		-tags [list rect$i list$i]
	$list create text $textCoords -text [gameString $i] \
		-anchor $textAnchor \
		-width $textWidth \
		-fill [textColor $i] \
		-font $listFont \
		-tags [list text$i list$i]
	$list create image $imageCoords -image [$imageFn $i $imageScale] \
		-anchor $imageAnchor -tags [list image$i list$i]
	}
	selectGame $currentId
}

proc scrollEnter canvas {
	global currentId
	set id [getIdUnderMouse $canvas]
	if { $currentId != $id } {
	$canvas itemconfigure rect$id -fill RoyalBlue
	$canvas itemconfigure text$id -fill white
	}
}

proc scrollLeave list {
	global currentId
	set id [getIdUnderMouse $list]
	if { $currentId != $id } {
	$list itemconfigure rect$id -fill [gameColor $id]
	$list itemconfigure text$id -fill [textColor $id]
	}
}

proc scrollButton list {
	selectGame [getIdUnderMouse $list]
}

proc scrollDoubleClick list {
	set i [getIdUnderMouse $list]
	if { [guiExists $i] } {
	runGui $i
	} else {
	runText $i
	}
}

proc mouseWheelUp { } {
	global scrollDirection
	set leftScroll .leftSide.leftScroll
	set list .leftSide.list
	set first [lindex [$leftScroll get] 0]
	$list [axisView] scroll -1 units
}

proc mouseWheelDown { } {
	global scrollDirection
	set leftScroll .leftSide.leftScroll
	set list .leftSide.list
	set first [lindex [$leftScroll get] 0]
	$list [axisView] scroll 1 units
}

proc Resize { } {
	global Desc Rules currentGame
	set home .rightSide.home
	set width [pageWidth]
	$home.$currentGame.title configure -width [expr $width - 20]
	if { [info exists Desc($currentGame)] } {
	$home.$currentGame.desc configure -width [expr $width - 20]
	}
	if { [info exists Rules($currentGame)] } {
	$home.$currentGame.rules configure -width [expr $width - 20]
	}
	if { $currentGame == "main" } {
	$home.main.desc configure -width [expr $width - 20]
	}
}

proc CreateGamePages { frame } {
	global theNumberOfPrograms calBlue Desc Rules

	set width [pageWidth]
	set height [expr [winfo height .] - 30]
	
	##### Starting Page ########
	set bgcolor $calBlue
	set fontcolor white
	canvas $frame.main -background $bgcolor -highlightthickness 0
	message $frame.main.title -text "GAMESMAN" \
	-anchor center \
	-background $bgcolor \
	-foreground $fontcolor \
	-width [expr $width - 20] \
	-font "Helvetica 20 bold"
	message $frame.main.desc -text \
	"A Finite, Two-Person, Perfect-Information Game Generator.\
	\n\n\tGamesman, which stands for Game-independent Automatic Move/position-tree Exhaustive-Search, Manipulation And Navigation, takes in the description of any game as an input and generates an application that will play the given game perfectly. Unlike any other toolkit, GAMESMAN allows the users to modify the rules of the game, play against a perfect opponent, receive a hint for the best move by a perfect player, and easily prototype a new game. It uses an exhaustive search tree to quantify the value of various playing strategies against a perfect player that knows the complete game tree. Therefore, at any stage in the game, the program knows all possible moves and their values, either a win, lose, or tie. This program, unlike other combinatorial and computational game theory toolkits (e.g. games and cgsuite), allows you to play the game graphically.\
	\n\tSince 2000, we have been modifying GAMESMAN's core to make it faster and more efficient, a friendlier user interface has been developed, more games have been added, and new games have been analyzed.\
\n\nSelect one of the $theNumberOfPrograms games from the list to learn more about it." \
	-anchor nw \
	-background $bgcolor \
	-foreground $fontcolor \
	-width [expr $width - 20]

	pack $frame.main.title -anchor n -pady [list 10 0]
	pack $frame.main.desc -expand 1 -anchor n

	pack $frame.main -expand 1 -fill both -anchor nw
	## end start page ##

	set docPath "../doc/"

	### this loop creates default content for game specific pages
	for { set i 0 } { $i < $theNumberOfPrograms } { incr i } {
		set gameName [gameName $i]
		set gameString [gameString $i]
		set theColor [gameColor $i]
		set borderWidth 5
		set bgcolor $calBlue
		set fontcolor white
		canvas $frame.$gameName -background $bgcolor -highlightthickness 0
		message $frame.$gameName.title -text $gameString -anchor center -width [expr $width - 20]\
			-foreground $fontcolor -background $bgcolor -font "Helvetica 20 bold"
	
		canvas $frame.$gameName.buttons -background $bgcolor -highlightthickness 0
	
		pack $frame.$gameName.title -pady [list 5 0]
			pack $frame.$gameName.buttons
	
		set fileName d$gameName.txt
		parseInfo [file join $docPath $fileName]
		
		if {[guiExists $i]} {
			button $frame.$gameName.buttons.guiButton \
			-image [guiImage $i 1] \
			-text "Play GUI" \
			-compound top \
			-bg $theColor \
			-borderwidth $borderWidth \
			-command "runGui $i"
			pack $frame.$gameName.buttons.guiButton -side left
		}
	
		button $frame.$gameName.buttons.textButton \
			-image [textImage $i 1] \
			-text "Play Text" \
			-compound top \
			-bg black \
			-fg white \
			-borderwidth $borderWidth \
			-command "runText $i"
			pack $frame.$gameName.buttons.textButton -side left
	
		if { [info exists Desc($gameName)] } {
			message $frame.$gameName.desc -text $Desc($gameName) -width [expr $width - 20]\
			-foreground $fontcolor -background $bgcolor -anchor nw
			pack $frame.$gameName.desc
		}
	
		if { [info exists Rules($gameName)] } {
			message $frame.$gameName.rules -text $Rules($gameName) -width [expr $width - 20]\
			-foreground $fontcolor -background $bgcolor -anchor nw
			pack $frame.$gameName.rules -anchor n -expand 1
		}
	}
}

### Call the main procedure.
main
