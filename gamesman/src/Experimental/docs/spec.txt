
Gamesman Core Specification


Table of Contents:

	I.	Design goals
	II.	Design overview
	III.	Possibilities
	IV.	Repositories
	V.	Databases
	VI.	Games
	VII.	Solvers
	VIII.	Implementing cool stuff


I.	Design Goals

	This system is designed with the following goals in mind.
	
	A.	Modularity.  A modular system is far easier to extend and
		maintain than one that is not.
	B.	Backwards compatibility for older games.  With this
		specification, a module can be placed inbetween old game
		modules and the architecture to run the game.


II.	Design Overview

	The architecture is designed in an object-oriented manner, despite
	the fact that it is programmed in a language with no native support
	for such a paradigm.  Nevertheless, the system can be broken down
	into three main "classes" (which are basically structs that have
	data and function pointers).  Here is an overview of them.
	
	A.	GAME
		
		Contains all of the data and functions that make up a game
		module in gamesman.  This includes information regarding the
		gametree, rule and board options, and functions that
		determine the rules of the game.
	
	B.	DATABASE
		
		Stores and retrieves records.  Does nothing more.  Databases
		are used to manipulate and save game information.  The
		information can be stored on many different media and using
		many different methods, which is why this layer of
		abstraction is provided.  Examples include memory, file,
		compressed file, and remote server.
	
	C.	SOLVER
	
		Solves a game and stores the related game information into a
		DATABASE.  After a game has been solved, the class is still
		used to retrieve information about the gametree, since the
		DATABASE knows nothing about how the data it contains is
		stored (it only knows to store the data).  The solver
		determines what is stored and how.


III.	Possibilities

	Because of the simplicity of the system, and the abstractions made,
	there are many possibilities for future extensions.  Some of the
	possibilities are listed here, and more detailed information about
	-how- to implement these ideas are listed at the end of the
	document.

	A.	Gametree stored remotely
	
		Not all computers are capable of solving very large games,
		and some of them aren't even capable of storing the
		information for these games.  Having a well-equipped
		computer solve a game once, and then another that can serve
		the data generated by that solver would allow users to play
		games without solving them.
	
	...

And now the part that I haven't gotten to... -JJ

---- snip ----

The main() function of the program should initialize two repositories, one
for solver classes and the other for database classes.  These 'repositories'
remember the list of classes that are available in the system, and can be
called upon to look those classes up by name or prefix handler (see
databases, later).  Here are the provisions to interact with these
repositories:

void db_init()
	Contains calls to db_load() with the linked-in database information. 
	If you want to link in a database to the system permanently, you should
	make the db_load() call here.

void db_load(DATABASE_CLASS*)
	Loads the contents of the given class structure to the repository.
	Each built-in class has one of these records, and a function that
	returns one.

DATABASE_CLASS* db_find_handler(STRING)
	Locates the database class associated with the given resource (ie, a
	string that describes a database "file:///something.db", "memory:",
	"soap://somewhere.org:1080/gobblet", etc), and returns it.

DATABASE* db_open(STRING)
	Finds the class to handle the given resource, and opens the resource.
	Returns the object (database instance) of the open database.


The database class file should include a few functions as well:

- An initialization function that builds a DATABASE_CLASS* object and
returns it.  This is the first entry point for any database, and is usually
called from db_init().  The name can be anything as long as it's unique. 
Memdb's is memdb_init().  This should be the only function exported from the
module (the rest should be static).  The definition for a DATABASE* object
is in include/types.h.  The functions that go in it will be described
further down.  First, here is what should go in a DATABASE_CLASS structure:

class_name
	The name of the class.  This can be anything, but should be one
	word.  Such as "memdb".

prefix
	The string of the prefix that this db handles.  Memory db's handle
	"memory".  File db's should handle "file".

properties
	A table of data.  See memdb.c and docs/tablspec.txt.

create(STRING)
	See the next entry.

- A constructor that creates a database instance (ie, it returns type
DATABASE*).  This function should take in a STRING argument, that specifies
the resource to use.  For a file database, this should be of the format
"file://./data/somegame_1.dat" or perhaps "file:./data/somegame_1.dat" or
even "file:data/somegame_1.dat".  If the resource doesnt exist it should be
created.  Memory databases dont have filenames, so you call
db_open("memory:") to create a new one.

- And of course, there must be the functions that drive the database.  Here
is what it breaks down into:

init(DATABASE*, POSITION, int)
	Clears the database.  Sets the record count to the second argument
	and the record size (in BITS -- see bits.c) in the third argument.

free(DATABASE*)
	Frees the database, and the pointer that was passed in (so it does
	not need to be freed later)

get(DATABASE*, POSITION, void*)
	Retrieves the entry specified by the second argument, and places it
	in the memory pointed to by the third argument.  See memdb.c for an
	example.

put(DATABASE*, POSITION, void*)
	Stores the entry specified by the second argument from the data
	pointed to by the third argument.  See memdb.c for an example.

putn(DATABASE*, POSITION, void*, int)
	Puts n (4th arg) entries, from the memory pointed to by the third
	argument into the database starting at the index of the 2nd argument.

transfer(DATABASE* src, DATABASE* dest)
	Initializes the target database (by calling its init function) with
	the correct record count and size, and transfers all entries from src to
	dest through a series of dest's putn calls.  memdb.c isn't a good example
	of this, because it should probably call lots of times, and be checking
	the results of those calls (and returning an error if one of them fails).
